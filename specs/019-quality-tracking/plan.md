# Implementation Plan: Quality Tracking & Backend Profiling

**Branch**: `019-quality-tracking` | **Date**: 2025-01-24 | **Spec**: [specs/019-quality-tracking/spec.md](./spec.md)  
**Input**: Feature specification from `/specs/019-quality-tracking/spec.md`

**Note**: This plan was generated by the `/speckit.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

Build performance profiles for each model+backend combination using rolling window statistics. The system tracks error rates (1-hour window), success rates (24-hour window), and time-to-first-token (TTFT) metrics. These quality profiles feed directly into the router scoring algorithm to automatically exclude degraded backends and penalize slow backends, delivering consistent performance and reliability without manual intervention.

**Technical Approach**: 
- Use `VecDeque<RequestOutcome>` with periodic pruning for memory-efficient rolling windows
- Store metrics in `DashMap` for lock-free per-agent concurrent access
- Background reconciliation loop recomputes metrics every 30 seconds (configurable)
- Quality metrics feed into QualityReconciler (binary exclusion) and SchedulerReconciler (TTFT penalty scoring)
- Expose metrics via Prometheus gauges and JSON `/v1/stats` endpoint

## Technical Context

**Language/Version**: Rust 1.87 (edition 2021)  
**Primary Dependencies**: 
- `tokio` 1.x (async runtime, interval timer for reconciliation loop)
- `dashmap` 6.x (lock-free concurrent map for quality metrics store)
- `metrics` 0.24 + `metrics-exporter-prometheus` 0.16 (Prometheus integration)
- `serde` 1.x (JSON serialization for /v1/stats endpoint)
- `axum` 0.7 (HTTP framework for API endpoints)

**Storage**: In-memory only (DashMap + VecDeque). No persistence required per constitution principle VII (Stateless by Design).

**Testing**: 
- `cargo test` (unit tests in `src/agent/quality.rs`)
- `proptest` 1.x (property-based testing for metric bounds)
- `wiremock` 0.6 (mock backends for integration tests)

**Target Platform**: Linux server (primary), macOS, Windows (cross-platform via Rust stdlib)

**Project Type**: Single binary server application (Nexus orchestrator)

**Performance Goals**: 
- Routing overhead: <1ms per request (constitution requirement)
- Quality metric read: <10μs (O(1) DashMap lookup)
- Reconciliation loop: <1ms for 100 backends (30-second interval)
- Memory baseline: ~5MB for 10 backends × 24-hour history (within 50MB target)

**Constraints**: 
- No external storage dependencies (in-memory only)
- Thread-safe concurrent access (multiple routing decisions + background reconciliation)
- Zero allocation on routing hot path (metrics read from cached DashMap)
- Monotonic time sources (Instant) for clock-skew resilience

**Scale/Scope**: 
- **Backends**: 10-100 concurrent backends
- **Request rate**: 10,000 req/sec fleet-wide
- **Metric cardinality**: 200 agent_id labels (10 backends × 20 models)
- **Rolling window retention**: 24 hours max (1-hour + 24-hour windows)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Simplicity Gate
- [x] Using ≤3 main modules for initial implementation?
  - **YES**: 3 modules: `agent/quality.rs` (store), `routing/reconciler/quality.rs` (exclusion logic), `routing/reconciler/scheduler.rs` (TTFT penalty)
- [x] No speculative "might need" features?
  - **YES**: Implementing only required metrics (error_rate_1h, success_rate_24h, avg_ttft_ms per spec)
- [x] No premature optimization?
  - **YES**: Using stdlib VecDeque + DashMap. No custom ring buffers or parallel recomputation yet.
- [x] Start with simplest approach that could work?
  - **YES**: Periodic batch recomputation (30s interval) vs. complex incremental updates

### Anti-Abstraction Gate
- [x] Using Axum/Tokio/reqwest directly (no wrapper layers)?
  - **YES**: Direct Tokio interval timer, no wrapper framework
- [x] Single representation for each data type?
  - **YES**: `AgentQualityMetrics` is the single canonical representation (no DTO/entity split)
- [x] No "framework on top of framework" patterns?
  - **YES**: Using `metrics` crate facade directly, no custom abstraction layer
- [x] Abstractions justified by actual (not theoretical) needs?
  - **YES**: `QualityMetricsStore` encapsulates concurrent access (actual need: thread safety)

### Integration-First Gate
- [x] API contracts defined before implementation?
  - **YES**: See `contracts/stats-response.json` (JSON schema), `contracts/prometheus-metrics.md`
- [x] Integration tests planned with real/mock backends?
  - **YES**: Wiremock-based tests for simulating degraded backends
- [x] End-to-end flow testable?
  - **YES**: Request → record_outcome → recompute → QualityReconciler → exclusion

### Performance Gate
- [x] Routing decision target: < 1ms?
  - **YES**: Quality metric read is O(1) DashMap lookup (~10μs)
- [x] Total overhead target: < 5ms?
  - **YES**: Routing adds ~10μs (quality read) + reconciler logic (<100μs)
- [x] Memory baseline target: < 50MB?
  - **YES**: ~5MB for 10 backends × 24h history

**All gates passed.** No violations to track in Complexity Tracking section.

## Project Structure

### Documentation (this feature)

```text
specs/019-quality-tracking/
├── spec.md              # Feature specification (input)
├── plan.md              # This file (/speckit.plan command output)
├── research.md          # Phase 0 output: rolling window algorithms, Prometheus patterns
├── data-model.md        # Phase 1 output: AgentQualityMetrics, QualityMetricsStore entities
├── quickstart.md        # Phase 1 output: developer guide
├── contracts/           # Phase 1 output: API contracts
│   ├── stats-response.json       # JSON schema for /v1/stats endpoint
│   └── prometheus-metrics.md     # Prometheus metrics specification
├── checklists/          # Quality assurance checklists (separate workflow)
└── tasks.md             # Phase 2 output (/speckit.tasks command - NOT created by /speckit.plan)
```

### Source Code (repository root)

**Nexus uses a single binary server architecture** with modular source organization:

```text
src/
├── agent/
│   ├── mod.rs           # Agent abstractions, AgentProfile
│   ├── quality.rs       # QualityMetricsStore, RequestOutcome, recomputation logic
│   ├── types.rs         # AgentQualityMetrics struct
│   └── [backends]/      # Backend-specific implementations (ollama, openai, etc.)
│
├── config/
│   ├── mod.rs           # NexusConfig aggregator
│   └── quality.rs       # QualityConfig (thresholds, intervals)
│
├── routing/
│   ├── mod.rs           # Router orchestration
│   ├── reconciler/
│   │   ├── mod.rs       # Reconciler pipeline
│   │   ├── quality.rs   # QualityReconciler (exclusion logic)
│   │   └── scheduler.rs # SchedulerReconciler (TTFT penalties) [MODIFIED]
│   └── scoring.rs       # Scoring weights
│
├── metrics/
│   ├── mod.rs           # MetricsCollector, Prometheus setup
│   ├── handler.rs       # /v1/stats endpoint [MODIFIED]
│   └── types.rs         # StatsResponse structures
│
├── api/                 # HTTP API endpoints (existing)
├── dashboard/           # RequestHistory ring buffer (existing)
├── registry/            # Backend registry (existing)
├── health/              # Health check system (existing)
├── discovery/           # mDNS discovery (existing)
├── queue/               # Request queueing (existing)
├── logging/             # Structured logging (existing)
├── cli/                 # CLI commands (existing)
├── lib.rs               # Crate root
└── main.rs              # Entry point

tests/
├── contract/            # Contract tests for /v1/stats, /metrics endpoints
│   └── quality_api_test.rs
├── integration/         # Integration tests with mock backends
│   └── quality_routing_test.rs
└── unit/                # Unit tests (in-module via #[cfg(test)])
```

**Structure Decision**: 

Nexus follows the **single binary server pattern** as mandated by constitution principle II (Single Binary). This feature integrates into the existing modular architecture without introducing new binaries or services.

**Key Modifications**:
1. **New module**: `src/agent/quality.rs` (core quality tracking logic)
2. **New config**: `src/config/quality.rs` (configuration parsing)
3. **New reconciler**: `src/routing/reconciler/quality.rs` (routing exclusion logic)
4. **Modified reconciler**: `src/routing/reconciler/scheduler.rs` (add TTFT penalty scoring)
5. **Modified endpoint**: `src/metrics/handler.rs` (extend /v1/stats with quality metrics)
6. **Modified Prometheus**: `src/metrics/mod.rs` (export quality gauges)

**No new services, no new binaries, no external dependencies.** All code compiles into the single `nexus` binary.

## Complexity Tracking

> **All Constitution Gates Passed.** No violations to justify.

This section is intentionally left empty as no complexity violations were identified during the constitution check. The implementation follows Nexus's established patterns:
- Simple 3-module design (quality.rs, quality reconciler, scheduler updates)
- No new abstractions beyond justified thread-safety encapsulation
- Direct use of stdlib and established dependencies (Tokio, DashMap, metrics)
- Performance targets met with straightforward algorithms

---

## Implementation Phases

### Phase 0: Research ✅ COMPLETE

**Deliverables**:
- [x] `research.md` created with decisions on:
  - Rolling window data structures (VecDeque + periodic pruning)
  - Thread-safe concurrent access patterns (DashMap + RwLock)
  - Prometheus metrics patterns (gauges for ratios, histograms for latency)
  - Async reconciliation loop patterns (Tokio interval timer)
  - Handling incomplete data windows (safe defaults, confidence indicators)

**Key Findings**:
- VecDeque with 30-second batch recomputation is 33x more efficient than per-request updates
- DashMap provides per-agent lock isolation, avoiding global contention
- Monotonic time sources (Instant) prevent clock-skew issues

---

### Phase 1: Design & Contracts ✅ COMPLETE

**Deliverables**:
- [x] `data-model.md` with entity specifications:
  - AgentQualityMetrics (error_rate_1h, avg_ttft_ms, success_rate_24h, etc.)
  - RequestOutcome (timestamp, success, ttft_ms)
  - QualityMetricsStore (DashMap-based concurrent store)
  - QualityConfig (TOML configuration schema)
  - State management lifecycle diagrams
  - Validation rules and edge case handling

- [x] `contracts/` directory with API specifications:
  - `stats-response.json`: JSON schema for extended /v1/stats endpoint
  - `prometheus-metrics.md`: Prometheus metrics specification (gauges, histograms, PromQL examples)

- [x] `quickstart.md` developer guide covering:
  - Common tasks (adding metrics, tuning thresholds, debugging routing)
  - Testing strategies (unit, integration, property-based)
  - Performance tuning (reducing overhead, cardinality management)
  - Troubleshooting (metrics not updating, exclusions not working)

- [x] Agent context updated via `update-agent-context.sh copilot`

---

### Phase 2: Task Generation (NOT IN SCOPE)

**Phase 2 is executed separately via the `/speckit.tasks` command**, which generates `tasks.md` with:
- Actionable implementation tasks
- Dependency ordering
- Acceptance criteria per task
- Test-first development markers

**This plan document ends at Phase 1 design completion.** To proceed with implementation, run:
```bash
/speckit.tasks specs/019-quality-tracking/spec.md
```

---

## Next Steps

1. **Review artifacts**:
   - Read `research.md` for technical decisions
   - Review `data-model.md` for entity relationships
   - Check `contracts/` for API specifications
   - Use `quickstart.md` as implementation reference

2. **Generate tasks** (separate command):
   ```bash
   /speckit.tasks specs/019-quality-tracking/spec.md
   ```

3. **Begin implementation** (TDD workflow per constitution):
   - Write tests first (contract → integration → unit)
   - Confirm tests fail (Red phase)
   - Implement to make tests pass (Green phase)
   - Refactor while keeping tests green

4. **Monitor progress**:
   - Track task completion in `tasks.md` (generated separately)
   - Update acceptance criteria checkboxes
   - Run quality checklists: `specs/019-quality-tracking/checklists/`

---

## Feature Branch

**Branch**: `019-quality-tracking` (auto-created by setup-plan.sh)

**Artifacts Available**:
- ✅ Feature specification: `specs/019-quality-tracking/spec.md`
- ✅ Implementation plan: `specs/019-quality-tracking/plan.md` (this file)
- ✅ Research findings: `specs/019-quality-tracking/research.md`
- ✅ Data model: `specs/019-quality-tracking/data-model.md`
- ✅ API contracts: `specs/019-quality-tracking/contracts/`
- ✅ Developer quickstart: `specs/019-quality-tracking/quickstart.md`
- ⏸️ Implementation tasks: `specs/019-quality-tracking/tasks.md` (run `/speckit.tasks` to generate)

**Status**: Phase 0 & Phase 1 complete. Ready for task generation and implementation.

---

**Plan Generated**: 2025-01-24  
**Plan Version**: 1.0  
**Generated By**: `/speckit.plan` command
